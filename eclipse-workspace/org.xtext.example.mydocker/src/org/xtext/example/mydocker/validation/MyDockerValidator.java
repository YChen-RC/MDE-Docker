
/*
* generated by Xtext 2.30.0
*/
package org.xtext.example.mydocker.validation;

 

import java.util.*;

 

import org.eclipse.xtext.validation.Check;
import org.xtext.example.mydocker.myDocker.*;

 

/**
* This class contains custom validation rules. 
*
* See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
*/
public class MyDockerValidator extends AbstractMyDockerValidator {

public static final String INVALID_NAME = "invalidName";

 

@Check
public void checkDocker(Docker docker) {
}

@Check
public void checkCommand(Command cmd) {
  if (cmd instanceof Arg) {
   var arg = (Arg)cmd;
   if (arg.getArgs().getValue().isEmpty() && arg.getArgs().getValues().getValues().isEmpty()) {
    error("ARG argument should not empty", null); 
   }
  }
}

@Check
public void checkExposePortNotEmpty(Expose expose) {
  if (expose.getArgs().getPorts().isEmpty()) {
   error("port should be set", null);
  }

  for(ExposeArg port:expose.getArgs().getPorts()) {
   if (port.getPort() <= 0 && port.getPort_protocol().isEmpty()) {
    error("port should be set with a positive number", null);
   } else if (port.getPort_protocol().split("/")[0].equals("0")) {
    error("port should be set", null);
   }
  }
}

@Check
public void checkEnvNameShouldBeUpper(Env env) { 
  for(NameVal kv: env.getArgs().getValues()) {
   if (kv.getKey().isEmpty()) {
    error("name=value name should not empty", null);
   }
   if (!kv.getKey().equals(kv.getKey().toUpperCase())) {
    warning("name=value name should better be upper", null);
   }
  }
}

@Check
public void checkLabelKeysShouldNotRepeat(Docker docker) {
  Map<String, String> labels = new HashMap<String, String>();
  for (Command cmd: docker.getCommands()) {
   if (cmd instanceof Label) {
    var label = (Label)cmd;
    for(NameVal kv: label.getArgs().getValues()) {
     var key = kv.getKey();
     if (key.isEmpty()) {
      error("name=value name should not empty", null);
     }
     if (labels.containsKey(key)) {
      warning("label has same key " + key, null);
     }
    }  
   }
  }  
}

@Check
public void checkFromCommandExists(Docker docker) {
     long fromCommands = docker.getCommands().stream().filter(cmd -> cmd instanceof From).count();
     if (fromCommands == 0) {
         error("At least one FROM command is required in the Dockerfile", null);
     }
}

 

@Check
public void checkUniqueCommands(Docker docker) {
     Class<?>[] uniqueCommands = new Class<?>[]{Maintainer.class, StopSignal.class};
     for (Class<?> uniqueCommand : uniqueCommands) {
         long commandCount = docker.getCommands().stream().filter(uniqueCommand::isInstance).count();
         if (commandCount > 1) {
             warning("The " + uniqueCommand.getSimpleName() + " command should appear only once", null);
         }
     }
}

 

@Check
public void checkCmdAndEntrypointCompatibility(Docker docker) {
     Cmd cmd = null;
     Entrypoint entrypoint = null;

     for (Command command : docker.getCommands()) {
         if (command instanceof Cmd) {
             cmd = (Cmd) command;
         } else if (command instanceof Entrypoint) {
             entrypoint = (Entrypoint) command;
         }
     }

     if (cmd != null && entrypoint != null) {
         if (entrypoint.getArgs() instanceof JSONArgs && !(cmd.getArgs() instanceof JSONArgs)) {
             error("ENTRYPOINT is using JSON form, CMD should also use JSON form", null);
         }
     }
}

 

@Check
public void checkExposePortRange(Expose expose) {
     for (ExposeArg port : expose.getArgs().getPorts()) {
         if (port.getPort() < 1 || port.getPort() > 65535) {
             error("Port number must be within the range of 1 to 65535", null);
         }
     }
}
[17:31] Shahab Mehrnami




/*

* generated by Xtext 2.30.0

*/

package org.xtext.example.mydocker.validation;

 

import java.util.*;

 

import org.eclipse.xtext.validation.Check;

import org.xtext.example.mydocker.myDocker.*;

 

/**

* This class contains custom validation rules. 

*

* See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation

*/

public class MyDockerValidator extends AbstractMyDockerValidator {


public static final String INVALID_NAME = "invalidName";

 

@Check

public void checkDocker(Docker docker) {

}


@Check

public void checkCommand(Command cmd) {

  if (cmd instanceof Arg) {

   var arg = (Arg)cmd;

   if (arg.getArgs().getValue().isEmpty() && arg.getArgs().getValues().getValues().isEmpty()) {

    error("ARG argument should not empty", null); 

   }

  }

}


@Check

public void checkExposePortNotEmpty(Expose expose) {

  if (expose.getArgs().getPorts().isEmpty()) {

   error("port should be set", null);

  }


  for(ExposeArg port:expose.getArgs().getPorts()) {

   if (port.getPort() <= 0 && port.getPort_protocol().isEmpty()) {

    error("port should be set with a positive number", null);

   } else if (port.getPort_protocol().split("/")[0].equals("0")) {

    error("port should be set", null);

   }

  }

}


@Check

public void checkEnvNameShouldBeUpper(Env env) { 

  for(NameVal kv: env.getArgs().getValues()) {

   if (kv.getKey().isEmpty()) {

    error("name=value name should not empty", null);

   }

   if (!kv.getKey().equals(kv.getKey().toUpperCase())) {

    warning("name=value name should better be upper", null);

   }

  }

}


@Check

public void checkLabelKeysShouldNotRepeat(Docker docker) {

  Map<String, String> labels = new HashMap<String, String>();

  for (Command cmd: docker.getCommands()) {

   if (cmd instanceof Label) {

    var label = (Label)cmd;

    for(NameVal kv: label.getArgs().getValues()) {

     var key = kv.getKey();

     if (key.isEmpty()) {

      error("name=value name should not empty", null);

     }

     if (labels.containsKey(key)) {

      warning("label has same key " + key, null);

     }

    }  

   }

  }  

}


@Check

public void checkFromCommandExists(Docker docker) {

     long fromCommands = docker.getCommands().stream().filter(cmd -> cmd instanceof From).count();

     if (fromCommands == 0) {

         error("At least one FROM command is required in the Dockerfile", null);

     }

}

 

@Check

public void checkUniqueCommands(Docker docker) {

     Class<?>[] uniqueCommands = new Class<?>[]{Maintainer.class, StopSignal.class};

     for (Class<?> uniqueCommand : uniqueCommands) {

         long commandCount = docker.getCommands().stream().filter(uniqueCommand::isInstance).count();

         if (commandCount > 1) {

             warning("The " + uniqueCommand.getSimpleName() + " command should appear only once", null);

         }

     }

}

 

@Check

public void checkCmdAndEntrypointCompatibility(Docker docker) {

     Cmd cmd = null;

     Entrypoint entrypoint = null;


     for (Command command : docker.getCommands()) {

         if (command instanceof Cmd) {

             cmd = (Cmd) command;

         } else if (command instanceof Entrypoint) {

             entrypoint = (Entrypoint) command;

         }

     }


     if (cmd != null && entrypoint != null) {

         if (entrypoint.getArgs() instanceof JSONArgs && !(cmd.getArgs() instanceof JSONArgs)) {

             error("ENTRYPOINT is using JSON form, CMD should also use JSON form", null);

         }

     }

}

 

@Check

public void checkExposePortRange(Expose expose) {

     for (ExposeArg port : expose.getArgs().getPorts()) {

         if (port.getPort() < 1 || port.getPort() > 65535) {

             error("Port number must be within the range of 1 to 65535", null);

         }

     }

}




Xtext - Language Implementation




The website of Eclipse Xtext, an open-source framework for development of programming languages and domain-specific languages







[17:32] Shahab Mehrnami




@Check

public void checkWorkdirPath(Workdir workdir) {

     String path = workdir.getArgs().toString();

     if (path == null || path.isEmpty()) {

         error("Path in WORKDIR command should not be empty", null);

     } else if (!path.startsWith("/")) {

         warning("Path in WORKDIR command should be an absolute path", null);

     }

}

 



@Check

public void checkRequiredCommands(Docker docker) {

     boolean cmdExists = false;

     boolean entrypointExists = false;

 

     for (Command command : docker.getCommands()) {

         if (command instanceof Cmd) {

             cmdExists = true;

         } else if (command instanceof Entrypoint) {

             entrypointExists = true;

         }

     }

 

     if (!cmdExists && !entrypointExists) {

         error("At least one CMD or ENTRYPOINT command is required in the Dockerfile", null);

     }

}

 

@Check

public void checkJsonArgs(Command command) {

     if (command instanceof Cmd || command instanceof Entrypoint) {

         CommandArgs commandArgs = command instanceof Cmd ? ((Cmd) command).getArgs() : ((Entrypoint) command).getArgs();

         if (commandArgs instanceof JSONArgs) {

             JSONArgs jsonArgs = (JSONArgs) commandArgs;

             List<String> args = jsonArgs.getArgs();

 

             if (args.isEmpty()) {

                 error("JSON arguments in " + command.getCmd() + " command should not be empty", null);

                 return;

             }

 

             for (String arg : args) {

                 if (!isValidJsonString(arg)) {

                     error("Invalid JSON argument in " + command.getCmd() + " command: " + arg, null);

                 }

             }

         }

     }

}

 

private boolean isValidPath(String path) {

     // This is a simple check for a valid path. You can modify this method to add more specific validation rules.

     if (path == null || path.isEmpty()) {

         return false;

     }

     return true;

}

 

private boolean isValidJsonString(String jsonString) {

  return false;

}

 

 



}